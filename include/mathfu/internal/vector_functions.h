/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef MATHFU_INTERNAL_VECTOR_UTIL_H_
#define MATHFU_INTERNAL_VECTOR_UTIL_H_

#include <type_traits>
#include "mathfu/internal/simd.h"
#include "mathfu/internal/vector_types.h"
#include "mathfu/utilities.h"

namespace mathfu {
namespace internal {

// Disable spurious warnings generated by MATHFU_VECTOR_OPERATION().
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4127)  // conditional expression is constant
#if _MSC_VER >= 1900             // MSVC 2015
#pragma warning(disable : 4456)  // allow shadowing in unrolled loops
#endif                           // _MSC_VER >= 1900
#elif defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warray-bounds"
#endif

// Macro that can be used to determine the number of elements stored in the
// data_ member of a vector.
#define MATHFU_VECTOR_SIZE sizeof(Vec::data_) / sizeof(Vec::data_[0])

// Macro that can be used to apply OP to every element of a vector.  The
// variable 'i' can be used in the OP expansion to specify the specific element.
#define MATHFU_VECTOR_FOR_EACH(OP) \
  MATHFU_UNROLLED_LOOP(i, MATHFU_VECTOR_SIZE, OP)

// Template for determining the data type (eg. int, float, double, etc.) stored
// in a mathfu data type (as long as it defines a data_ member.)
template <typename Vec>
using ValueType = std::decay<decltype(Vec::data_[0])>;

// The rest of this file implements various vector functions that can be
// used on both scalar and simd vector implementations. Because these are all
// templated functions, these can actually be used on any data structure that,
// at the very least, provides a member variable data_[T] array. We then use
// SFINAE and the MATHFU_ENABLE_IF macro to further specialize these functions
// to support SIMD types. See simd_util.h for more information.

// Assigns (ie. copies) the vector from src to dst.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
void AssignHelper(Vec* dst, const Vec& src) {
  MATHFU_VECTOR_FOR_EACH(dst->data_[i] = src.data_[i]);
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
void AssignHelper(Vec* dst, const Vec& src) {
  dst->simd = src.simd;
}

// Returns true if the values in v1 are equal to v2, false otherwise.
template <class Vec>
bool EqualHelper(const Vec& v1, const Vec& v2) {
  for (int i = 0; i < MATHFU_VECTOR_SIZE; ++i) {
    if (v1.data_[i] != v2.data_[i]) {
      return false;
    }
  }
  return true;
}

// Returns true if the values in v1 are not equal to v2, false otherwise.
template <class Vec>
bool NotEqualHelper(const Vec& v1, const Vec& v2) {
  return !EqualHelper(v1, v2);
}

// Returns a copy of the vector v, but with negated values.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec NegateHelper(const Vec& v) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = -v.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec NegateHelper(const Vec& v) {
  return Vec(simd_sub(simd_zero(v.simd), v.simd));
}

// Adds a scalar to each element of a vector (eg. scalar + vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec AddHelperSV(typename ValueType<Vec>::type s, const Vec& v) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = s + v.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec AddHelperSV(typename ValueType<Vec>::type s, const Vec& v) {
  return Vec(simd_add(simd_splat(v.simd, s), v.simd));
}

// Adds a scalar to each element of a vector (eg. vector + scalar).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec AddHelperVS(const Vec& v, typename ValueType<Vec>::type s) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = v.data_[i] + s);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec AddHelperVS(const Vec& v, typename ValueType<Vec>::type s) {
  return Vec(simd_add(v.simd, simd_splat(v.simd, s)));
}

// Adds a vector to another vector (eg. vector + vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec AddHelperVV(const Vec& v1, const Vec& v2) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = v1.data_[i] + v2.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec AddHelperVV(const Vec& v1, const Vec& v2) {
  return Vec(simd_add(v1.simd, v2.simd));
}

// Adds (in-place) a scalar to each element of a vector (eg. vector += scalar).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec& AddAssignHelperVS(Vec& v, typename ValueType<Vec>::type s) {
  MATHFU_VECTOR_FOR_EACH(v.data_[i] += s);
  return v;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec& AddAssignHelperVS(Vec& v, typename ValueType<Vec>::type s) {
  v.simd = simd_add(v.simd, simd_splat(v.simd, s));
  return v;
}

// Adds (in-place) a vector to another vector (eg. vector += vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec& AddAssignHelperVV(Vec& v1, const Vec& v2) {
  MATHFU_VECTOR_FOR_EACH(v1.data_[i] += v2.data_[i]);
  return v1;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec& AddAssignHelperVV(Vec& v1, const Vec& v2) {
  v1.simd = simd_add(v1.simd, v2.simd);
  return v1;
}

// Subtracts each vector element from a scalar (eg. scalar - vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec SubtractHelperSV(typename ValueType<Vec>::type s, const Vec& v) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = s - v.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec SubtractHelperSV(typename ValueType<Vec>::type s, const Vec& v) {
  return Vec(simd_sub(simd_splat(v.simd, s), v.simd));
}

// Subtracts a scalar from each element of a vector (eg. vector - scalar).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec SubtractHelperVS(const Vec& v, typename ValueType<Vec>::type s) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = v.data_[i] - s);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec SubtractHelperVS(const Vec& v, typename ValueType<Vec>::type s) {
  return Vec(simd_sub(v.simd, simd_splat(v.simd, s)));
}

// Subtracts a vector from another vector (eg. vector - vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec SubtractHelperVV(const Vec& v1, const Vec& v2) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = v1.data_[i] - v2.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec SubtractHelperVV(const Vec& v1, const Vec& v2) {
  return Vec(simd_sub(v1.simd, v2.simd));
}

// Subtracts (in-place) a scalar from each element of a vector
// (eg. vector += scalar).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec& SubtractAssignHelperVS(Vec& v, typename ValueType<Vec>::type s) {
  MATHFU_VECTOR_FOR_EACH(v.data_[i] -= s);
  return v;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec& SubtractAssignHelperVS(Vec& v1, typename ValueType<Vec>::type s) {
  v1.simd = simd_sub(v1.simd, simd_splat(v1.simd, s));
  return v1;
}

// Subtracts (in-place) a vector from another vector (eg. vector -= vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec& SubtractAssignHelperVV(Vec& v1, const Vec& v2) {
  MATHFU_VECTOR_FOR_EACH(v1.data_[i] -= v2.data_[i]);
  return v1;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec& SubtractAssignHelperVV(Vec& v1, const Vec& v2) {
  v1.simd = simd_sub(v1.simd, v2.simd);
  return v1;
}

// Multiplies a scalar to each element of a vector (eg. scalar * vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec MultiplyHelperSV(typename ValueType<Vec>::type s, const Vec& v) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = s * v.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec MultiplyHelperSV(typename ValueType<Vec>::type s, const Vec& v) {
  return Vec(simd_mul(simd_splat(v.simd, s), v.simd));
}

// Multiplies a scalar to each element of a vector (eg. vector * scalar).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec MultiplyHelperVS(const Vec& v, typename ValueType<Vec>::type s) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = v.data_[i] * s);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec MultiplyHelperVS(const Vec& v, typename ValueType<Vec>::type s) {
  return Vec(simd_mul(v.simd, simd_splat(v.simd, s)));
}

// Multiplies a vector with another vector (eg. vector * vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec MultiplyHelperVV(const Vec& v1, const Vec& v2) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = v1.data_[i] * v2.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec MultiplyHelperVV(const Vec& v1, const Vec& v2) {
  return Vec(simd_mul(v1.simd, v2.simd));
}

// Multiplies (in-place) a scalar to each element of a vector
// (eg. vector *= scalar).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec& MultiplyAssignHelperVS(Vec& v, typename ValueType<Vec>::type s) {
  MATHFU_VECTOR_FOR_EACH(v.data_[i] *= s);
  return v;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec& MultiplyAssignHelperVS(Vec& v, typename ValueType<Vec>::type s) {
  v.simd = simd_mul(v.simd, simd_splat(v.simd, s));
  return v;
}

// Multiplies (in-place) a vector with another vector (eg. vector *= vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec& MultiplyAssignHelperVV(Vec& v1, const Vec& v2) {
  MATHFU_VECTOR_FOR_EACH(v1.data_[i] *= v2.data_[i]);
  return v1;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec& MultiplyAssignHelperVV(Vec& v1, const Vec& v2) {
  v1.simd = simd_mul(v1.simd, v2.simd);
  return v1;
}

// Divides each vector element from a scalar (eg. scalar / vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec DivideHelperSV(typename ValueType<Vec>::type s, const Vec& v) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = s / v.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec DivideHelperSV(typename ValueType<Vec>::type s, const Vec& v) {
  return Vec(simd_div(simd_splat(v.simd, s), v.simd));
}

// Divides each element of a vector with a scalar (eg. vector / scalar).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec DivideHelperVS(const Vec& v, typename ValueType<Vec>::type s) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = v.data_[i] / s);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec DivideHelperVS(const Vec& v, typename ValueType<Vec>::type s) {
  return Vec(simd_div(v.simd, simd_splat(v.simd, s)));
}

// Divides a vector with another vector (eg. vector / vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec DivideHelperVV(const Vec& v1, const Vec& v2) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = v1.data_[i] / v2.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec DivideHelperVV(const Vec& v1, const Vec& v2) {
  return Vec(simd_div(v1.simd, v2.simd));
}

// Divides (in-place) each element of a vector by a scalar
// (eg. vector /= scalar).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec& DivideAssignHelperVS(Vec& v, typename ValueType<Vec>::type s) {
  MATHFU_VECTOR_FOR_EACH(v.data_[i] /= s);
  return v;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec& DivideAssignHelperVS(Vec& v, typename ValueType<Vec>::type s) {
  v.simd = simd_div(v.simd, simd_splat(v.simd, s));
  return v;
}

// Divides (in-place) a vector with another vector (eg. vector /= vector).
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec& DivideAssignHelperVV(Vec& v1, const Vec& v2) {
  MATHFU_VECTOR_FOR_EACH(v1.data_[i] /= v2.data_[i]);
  return v1;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec& DivideAssignHelperVV(Vec& v1, const Vec& v2) {
  v1.simd = simd_div(v1.simd, v2.simd);
  return v1;
}

// Returns the dot product of two vectors.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
typename ValueType<Vec>::type DotProductHelper(const Vec& v1, const Vec& v2) {
  typename ValueType<Vec>::type result = 0;
  MATHFU_VECTOR_FOR_EACH(result += v1.data_[i] * v2.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd2)>
typename ValueType<Vec>::type DotProductHelper(const Vec& v1, const Vec& v2) {
  return simd2f_get_x(simd2f_dot2(v1.simd2, v2.simd2));
}
template <class Vec, MATHFU_ENABLE_IF(simd3)>
typename ValueType<Vec>::type DotProductHelper(const Vec& v1, const Vec& v2) {
  return simd4f_dot3_scalar(v1.simd3, v2.simd3);
}
template <class Vec, MATHFU_ENABLE_IF(simd4)>
typename ValueType<Vec>::type DotProductHelper(const Vec& v1, const Vec& v2) {
  return simd4f_get_x(simd4f_dot4(v1.simd4, v2.simd4));
}

// Returns the hadamard product of two vectors.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec HadamardProductHelper(const Vec& v1, const Vec& v2) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = v1.data_[i] * v2.data_[i]);
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd2)>
Vec HadamardProductHelper(const Vec& v1, const Vec& v2) {
  return Vec(simd_mul(v1.simd2, v2.simd2));
}
template <class Vec, MATHFU_ENABLE_IF(simd3)>
Vec HadamardProductHelper(const Vec& v1, const Vec& v2) {
  return Vec(simd_mul(v1.simd3, v2.simd3));
}
template <class Vec, MATHFU_ENABLE_IF(simd4)>
Vec HadamardProductHelper(const Vec& v1, const Vec& v2) {
  return Vec(simd_mul(v1.simd4, v2.simd4));
}

// Returns the cross product of two 3D vectors.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec CrossProductHelper(const Vec& v1, const Vec& v2) {
  static_assert(Vec::Dims == 3, "Cross product only for 3D vectors");
  Vec result;
  result.data_[0] = v1.data_[1] * v2.data_[2] - v1.data_[2] * v2.data_[1];
  result.data_[1] = v1.data_[2] * v2.data_[0] - v1.data_[0] * v2.data_[2];
  result.data_[2] = v1.data_[0] * v2.data_[1] - v1.data_[1] * v2.data_[0];
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd3)>
Vec CrossProductHelper(const Vec& v1, const Vec& v2) {
  return Vec(simd4f_cross3(v1.simd3, v2.simd3));
}

// Returns the squared length of a vector.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
typename ValueType<Vec>::type LengthSquaredHelper(const Vec& v) {
  return DotProductHelper(v, v);
}
template <class Vec, MATHFU_ENABLE_IF(simd2)>
typename ValueType<Vec>::type LengthSquaredHelper(const Vec& v) {
  return simd2f_get_x(simd2f_dot2(v.simd2, v.simd2));
}
template <class Vec, MATHFU_ENABLE_IF(simd3)>
typename ValueType<Vec>::type LengthSquaredHelper(const Vec& v) {
  return simd4f_dot3_scalar(v.simd3, v.simd3);
}
template <class Vec, MATHFU_ENABLE_IF(simd4)>
typename ValueType<Vec>::type LengthSquaredHelper(const Vec& v) {
  return simd4f_get_x(simd4f_dot4(v.simd4, v.simd4));
}

// Returns the length of a vector.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
typename ValueType<Vec>::type LengthHelper(const Vec& v) {
  return sqrt(LengthSquaredHelper(v));
}
template <class Vec, MATHFU_ENABLE_IF(simd2)>
typename ValueType<Vec>::type LengthHelper(const Vec& v) {
  return simd2f_get_x(simd2f_length2(v.simd2));
}
template <class Vec, MATHFU_ENABLE_IF(simd3)>
typename ValueType<Vec>::type LengthHelper(const Vec& v) {
  return simd4f_get_x(simd4f_length3(v.simd3));
}
template <class Vec, MATHFU_ENABLE_IF(simd4)>
typename ValueType<Vec>::type LengthHelper(const Vec& v) {
  return simd4f_get_x(simd4f_length4(v.simd4));
}

// Normalizes (in-place) a vector and returns its original length.
template <class Vec>
typename ValueType<Vec>::type NormalizeHelper(Vec& v) {
  const auto length = LengthHelper(v);
  const auto one_over_length = typename ValueType<Vec>::type(1) / length;
  MultiplyAssignHelperVS(v, one_over_length);
  return length;
}

// Returns a normalized vector.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec NormalizedHelper(const Vec& v) {
  const auto length = LengthHelper(v);
  const auto one_over_length = typename ValueType<Vec>::type(1) / length;
  return v * one_over_length;
}
template <class Vec, MATHFU_ENABLE_IF(simd2)>
Vec NormalizedHelper(const Vec& v) {
  return Vec(simd2f_normalize2(v.simd2));
}
template <class Vec, MATHFU_ENABLE_IF(simd3)>
Vec NormalizedHelper(const Vec& v) {
  return Vec(simd4f_normalize3(v.simd3));
}
template <class Vec, MATHFU_ENABLE_IF(simd4)>
Vec NormalizedHelper(const Vec& v) {
  return Vec(simd4f_normalize4(v.simd4));
}

// Returns a vector that is a linear interpolation between two vectors by the
// given percentage.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec LerpHelper(const Vec& v1, const Vec& v2, typename ValueType<Vec>::type percent) {
  const auto one_minus_percent = static_cast<typename ValueType<Vec>::type>(1.0) - percent;
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result[i] = (one_minus_percent * v1.data_[i]) +
                                     (percent * v2.data_[i]));
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec LerpHelper(const Vec& v1, const Vec& v2, typename ValueType<Vec>::type percent) {
  const auto simd_percent = simd_splat(v1.simd, percent);
  const auto simd_one = simd_splat(simd_percent, 1.0f);
  const auto simd_one_minus_percent = simd_sub(simd_one, simd_percent);
  const auto a = simd_mul(simd_one_minus_percent, v1.simd);
  const auto b = simd_mul(simd_percent, v2.simd);
  return Vec(simd_add(a, b));
}

// Returns a vector that contains the per-element maximum values of two vectors.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec MaxHelper(const Vec& v1, const Vec& v2) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result.data_[i] = std::max(v1.data_[i], v2.data_[i]));
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec MaxHelper(const Vec& v1, const Vec& v2) {
  return Vec(simd_max(v1.simd, v2.simd));
}

// Returns a vector that contains the per-element minimum values of two vectors.
template <class Vec, MATHFU_ENABLE_IF(scalar)>
Vec MinHelper(const Vec& v1, const Vec& v2) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result.data_[i] = std::min(v1.data_[i], v2.data_[i]));
  return result;
}
template <class Vec, MATHFU_ENABLE_IF(simd)>
Vec MinHelper(const Vec& v1, const Vec& v2) {
  return Vec(simd_min(v1.simd, v2.simd));
}

// Returns the angle between two vectors.
template <typename Vec>
typename ValueType<Vec>::type AngleHelper(const Vec& v1, const Vec& v2) {
  // Applying law of cosines.
  // https://stackoverflow.com/questions/10507620/finding-the-angle-between-vectors
  using U = typename ValueType<Vec>::type;
  const U divisor = LengthHelper(v1) * LengthHelper(v2);
  if (divisor == U(0)) {
    return U(0);
  }
  const U cos_val = DotProductHelper(v1, v2) / divisor;
  // If floating point error makes cos_val > 1, then acos will return nan.
  return cos_val <= U(1) ? std::acos(cos_val) : U(0);
}

// Returns a random vector within the range [min, max).
template <typename Vec>
Vec RandomInRangeHelper(const Vec& min, const Vec& max) {
  Vec result;
  using U = typename ValueType<Vec>::type;
  MATHFU_VECTOR_FOR_EACH(
      result.data_[i] = mathfu::RandomInRange<U>(min.data_[i], max.data_[i]));
  return result;
}

// Returns a vector where each element is rounded up to the next power of two.
template <typename Vec, typename U = typename ValueType<Vec>::type>
Vec RoundUpToPowerOf2(const Vec& v) {
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result.data_[i] =
                             mathfu::RoundUpToPowerOf2(v.data_[i]));
  return result;
}

// Clamps each element of a vector between the lower and upper bounds.
template <typename Vec, typename U = typename ValueType<Vec>::type>
Vec Clamp(const Vec& v, const Vec& lower, const Vec& upper) {
  return Vec::Max(lower, Vec::Min(v, upper));
}

// Converts an abitrary vector-like "compatible" object to a vector.
template <typename Vec, typename CompatibleT>
Vec FromTypeHelper(const CompatibleT& compatible) {
  // Use a union instead of reinterpret_cast to avoid aliasing bugs.
  using U = typename ValueType<Vec>::type;
  union ConversionUnion {
    ConversionUnion() {}  // C++11.
    CompatibleT compatible;
    U data[MATHFU_VECTOR_SIZE];
  } tmp;
  static_assert(sizeof(CompatibleT) >= sizeof(sizeof(U) * MATHFU_VECTOR_SIZE),
                "Conversion size mismatch.");

  tmp.compatible = compatible;
  Vec result;
  MATHFU_VECTOR_FOR_EACH(result.data_[i] = tmp.data[i]);
  return result;
}

// Converts a vector to an abitrary vector-like "compatible" object.
template <typename Vec, typename CompatibleT>
CompatibleT ToTypeHelper(const Vec& v) {
  // Use a union instead of reinterpret_cast to avoid aliasing bugs.
  using U = typename ValueType<Vec>::type;
  union ConversionUnion {
    ConversionUnion() {}
    CompatibleT compatible;
    U data[MATHFU_VECTOR_SIZE];
  } tmp;
  static_assert(sizeof(CompatibleT) >= sizeof(sizeof(U) * MATHFU_VECTOR_SIZE),
                "Conversion size mismatch.");

  MATHFU_VECTOR_FOR_EACH(tmp.data[i] = v.data_[i]);
  return tmp.compatible;
}

// Restore warnings.
#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#endif

}  // namespace internal
}  // namespace mathfu

#endif  // MATHFU_INTERNAL_VECTOR_UTIL_H_
